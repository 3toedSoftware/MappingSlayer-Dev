<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Sign Template Maker</title>
        <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
        <!-- LibLouis for proper Grade 2 Braille translation -->
        <script src="lib/liblouis/easy-api.js"></script>
        <script src="lib/liblouis/build-no-tables-utf16.js"></script>
        <!-- Fallback Grade 2 if LibLouis fails -->
        <script src="braille-grade2.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
                background: #f0f0f0;
            }

            .container {
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }

            .controls {
                flex: 0 0 auto;
                width: 400px;
                max-width: 400px;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                overflow: hidden;
            }

            .sign-preview {
                flex: 1;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            h1 {
                color: #003875;
                margin-top: 0;
            }

            h2 {
                color: #003875;
                font-size: 1.2em;
                margin-top: 0;
            }

            label {
                display: block;
                margin-bottom: 5px;
                color: #666;
                font-weight: bold;
            }

            input[type='text'],
            textarea,
            select {
                width: 100%;
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 14px;
                box-sizing: border-box;
            }

            textarea {
                min-height: 100px;
                resize: vertical;
            }

            .input-group {
                margin-bottom: 15px;
            }

            .dimensions {
                display: flex;
                gap: 10px;
            }

            .dimensions .input-group {
                flex: 1;
            }

            input[type='number'] {
                width: 100%;
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-sizing: border-box;
            }

            #svg-container {
                border: 1px solid #ddd;
                background: #fafafa;
            }

            .info {
                background: #e3f2fd;
                padding: 10px;
                border-radius: 4px;
                margin-top: 15px;
                font-size: 0.9em;
                color: #1976d2;
            }

            .presets {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
            }

            .preset-btn {
                padding: 8px 12px;
                background: #003875;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            }

            .preset-btn:hover {
                background: #002855;
            }

            .debug-info {
                background: #fff3cd;
                color: #856404;
                padding: 10px;
                border-radius: 4px;
                margin-top: 10px;
                font-size: 0.85em;
                font-family: monospace;
            }

            /* Tab styles */
            .tabs {
                display: flex;
                gap: 5px;
                margin-bottom: 20px;
                border-bottom: 2px solid #ddd;
                overflow-x: auto;
                max-width: 100%;
                scrollbar-width: thin;
            }

            /* Style the scrollbar for webkit browsers */
            .tabs::-webkit-scrollbar {
                height: 6px;
            }

            .tabs::-webkit-scrollbar-track {
                background: #f1f1f1;
            }

            .tabs::-webkit-scrollbar-thumb {
                background: #888;
                border-radius: 3px;
            }

            .tabs::-webkit-scrollbar-thumb:hover {
                background: #555;
            }

            .tab-button {
                padding: 10px 12px;
                background: #f0f0f0;
                border: none;
                border-radius: 8px 8px 0 0;
                cursor: pointer;
                font-weight: bold;
                color: #666;
                transition: all 0.3s ease;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                flex: 1 1 auto;
                min-width: 40px;
                max-width: 100px;
            }

            .tab-button:hover {
                background: #e0e0e0;
            }

            .tab-button.active {
                background: #003875;
                color: white;
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }

            .tab-button.add-tab {
                background: #4caf50;
                color: white;
                font-size: 18px;
                padding: 10px 15px;
                min-width: 40px;
                max-width: 40px;
                flex: 0 0 auto;
                overflow: visible;
                text-overflow: initial;
            }

            /* Keep SIGN DIMS button from shrinking */
            .tab-button[onclick*='dimensions'] {
                flex: 0 0 auto;
                min-width: auto;
                max-width: none;
            }

            .tab-button.add-tab:hover {
                background: #45a049;
            }

            .delete-tab-btn {
                background: #dc3545;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
                margin-top: 20px;
                width: 100%;
            }

            .delete-tab-btn:hover {
                background: #c82333;
            }

            /* Prevent text selection during dragging */
            .no-select {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            /* Prevent middle mouse auto-scroll on the SVG container */
            #svg-container {
                overflow: hidden;
            }

            #svg-container svg {
                touch-action: none; /* Prevent touch scrolling */
            }

            /* Context menu for logo */
            .logo-context-menu {
                display: none;
                position: fixed;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 15px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                min-width: 250px;
            }

            .logo-context-menu.show {
                display: block;
            }

            .logo-context-menu h3 {
                margin-top: 0;
                margin-bottom: 10px;
                color: #003875;
                font-size: 14px;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }

            .context-menu-group {
                margin-bottom: 10px;
            }

            .context-menu-group label {
                display: inline-block;
                width: 80px;
                font-size: 12px;
                color: #666;
                margin-bottom: 3px;
            }

            .context-menu-group input {
                width: 60px;
                padding: 4px;
                border: 1px solid #ddd;
                border-radius: 3px;
                font-size: 12px;
            }

            .context-menu-row {
                display: flex;
                gap: 10px;
                align-items: center;
                margin-bottom: 5px;
            }

            .context-menu-info {
                font-size: 11px;
                color: #888;
                margin-top: 5px;
            }
        </style>
    </head>
    <body>
        <div
            style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            "
        >
            <h1 style="margin: 0">Sign Template Maker</h1>
            <div>
                <button
                    id="save-template-btn"
                    style="
                        background: #4caf50;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        font-size: 14px;
                        cursor: pointer;
                        margin-right: 10px;
                    "
                >
                    💾 Save Template
                </button>
                <button
                    id="load-template-btn"
                    style="
                        background: #2196f3;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        font-size: 14px;
                        cursor: pointer;
                    "
                >
                    📁 Load Template
                </button>
                <input type="file" id="load-template-input" accept=".json" style="display: none" />
            </div>
        </div>

        <div class="container">
            <div class="controls">
                <!-- Tab navigation -->
                <div class="tabs" id="tabs-container">
                    <button class="tab-button active" onclick="switchTab('msg-1')">MSG1</button>
                    <button class="tab-button add-tab" onclick="addNewTab()">+</button>
                    <button class="tab-button" onclick="switchTab('dimensions')">SETTINGS</button>
                </div>

                <!-- Tab 1: MSG1 -->
                <div id="msg-1-tab" class="tab-content active" data-msg-id="1">
                    <div class="input-group">
                        <label for="sign-text">Sign Text:</label>
                        <textarea id="sign-text" placeholder="Enter sign text here...">
MSG1</textarea
                        >
                    </div>

                    <div class="input-group">
                        <label for="font-family">Font Family:</label>
                        <select id="font-family">
                            <option value="Arial, sans-serif">Arial</option>
                            <option value="Helvetica, sans-serif">Helvetica</option>
                            <option value="'Times New Roman', serif">Times New Roman</option>
                            <option value="Georgia, serif">Georgia</option>
                            <option value="'Courier New', monospace">Courier New</option>
                            <option value="Verdana, sans-serif">Verdana</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="font-upload">Upload Font File:</label>
                        <input
                            type="file"
                            id="font-upload"
                            accept=".ttf,.otf,.woff,.woff2"
                            style="margin-bottom: 5px"
                        />
                    </div>

                    <div class="dimensions">
                        <div class="input-group">
                            <label for="cap-height">Cap Height (px):</label>
                            <input
                                type="number"
                                id="cap-height"
                                value="62.5"
                                min="10"
                                max="150"
                                step="0.5"
                            />
                        </div>
                        <div class="input-group">
                            <label for="line-height">Line Height:</label>
                            <input
                                type="number"
                                id="line-height"
                                value="1.2"
                                min="0.8"
                                max="2"
                                step="0.1"
                            />
                        </div>
                    </div>

                    <div class="dimensions">
                        <div class="input-group">
                            <label for="letter-spacing">Letter Spacing (px):</label>
                            <input
                                type="number"
                                id="letter-spacing"
                                value="0"
                                min="-5"
                                max="20"
                                step="0.5"
                            />
                        </div>
                        <div class="input-group">
                            <label for="word-spacing">Word Spacing (px):</label>
                            <input
                                type="number"
                                id="word-spacing"
                                value="0"
                                min="-10"
                                max="30"
                                step="1"
                            />
                        </div>
                    </div>

                    <div class="dimensions">
                        <div class="input-group">
                            <label for="box-x">Text Area X (px):</label>
                            <input type="number" id="box-x" value="100" min="0" max="2000" />
                        </div>
                        <div class="input-group">
                            <label for="box-y">Text Area Y (px):</label>
                            <input type="number" id="box-y" value="200" min="0" max="2000" />
                        </div>
                    </div>

                    <div class="dimensions">
                        <div class="input-group">
                            <label for="box-width">Text Area Width (px):</label>
                            <input type="number" id="box-width" value="600" min="100" max="2000" />
                        </div>
                        <div class="input-group">
                            <label for="box-height">Text Area Height (px):</label>
                            <input type="number" id="box-height" value="200" min="100" max="2000" />
                        </div>
                    </div>

                    <div class="dimensions">
                        <div class="input-group">
                            <label for="text-h-align">Horizontal Align:</label>
                            <select id="text-h-align">
                                <option value="left">Left</option>
                                <option value="center" selected>Center</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="text-v-align">Vertical Align:</label>
                            <select id="text-v-align">
                                <option value="top">Top</option>
                                <option value="middle" selected>Middle</option>
                                <option value="bottom">Bottom</option>
                            </select>
                        </div>
                    </div>

                    <h2 style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px">
                        Braille Options
                    </h2>

                    <div class="input-group">
                        <label style="display: flex; align-items: center; cursor: pointer">
                            <input
                                type="checkbox"
                                id="enable-braille"
                                style="width: auto; margin-right: 10px"
                            />
                            <span>Add Braille Translation</span>
                        </label>
                    </div>

                    <div class="input-group">
                        <label for="braille-height">Braille Height (px):</label>
                        <input
                            type="number"
                            id="braille-height"
                            value="23.9"
                            min="10"
                            max="50"
                            step="0.1"
                        />
                    </div>

                    <div class="input-group">
                        <label for="braille-gap">Gap from Text (px):</label>
                        <input
                            type="number"
                            id="braille-gap"
                            value="40"
                            min="10"
                            max="100"
                            step="1"
                        />
                    </div>
                </div>

                <!-- Tab 2: Sign Dimensions -->
                <div id="dimensions-tab" class="tab-content">
                    <div class="input-group">
                        <label for="sign-width">Sign Width (px):</label>
                        <input
                            type="number"
                            id="sign-width"
                            value="800"
                            min="100"
                            max="2400"
                            step="1"
                        />
                    </div>

                    <div class="input-group">
                        <label for="sign-height">Sign Height (px):</label>
                        <input
                            type="number"
                            id="sign-height"
                            value="800"
                            min="100"
                            max="2400"
                            step="1"
                        />
                    </div>

                    <div class="input-group">
                        <label for="sign-dpi">DPI (for inch conversion):</label>
                        <input
                            type="number"
                            id="sign-dpi"
                            value="100"
                            min="72"
                            max="300"
                            step="1"
                        />
                    </div>

                    <div class="input-group">
                        <label style="display: flex; align-items: center; cursor: pointer">
                            <input
                                type="checkbox"
                                id="show-rulers"
                                checked
                                style="width: auto; margin-right: 10px"
                            />
                            <span>Show Rulers</span>
                        </label>
                    </div>

                    <h2 style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px">
                        Color Settings
                    </h2>

                    <div class="input-group">
                        <label for="sign-color">Sign Background Color:</label>
                        <input
                            type="color"
                            id="sign-color"
                            value="#f5f5f5"
                            style="width: 100%; height: 40px; cursor: pointer"
                        />
                    </div>

                    <div class="input-group">
                        <label for="text-color">Text Color:</label>
                        <input
                            type="color"
                            id="text-color"
                            value="#003875"
                            style="width: 100%; height: 40px; cursor: pointer"
                        />
                    </div>

                    <div class="input-group">
                        <label for="braille-color">Braille Color:</label>
                        <input
                            type="color"
                            id="braille-color"
                            value="#003875"
                            style="width: 100%; height: 40px; cursor: pointer"
                        />
                    </div>
                </div>
            </div>

            <div class="sign-preview">
                <h2>Sign Preview</h2>
                <div id="svg-container"></div>
                <div class="debug-info" id="debug-info">Initializing...</div>
            </div>
        </div>

        <!-- Logo Context Menu -->
        <div id="logo-context-menu" class="logo-context-menu">
            <h3>Logo Properties</h3>
            <div class="context-menu-group">
                <div class="context-menu-row">
                    <label>X:</label>
                    <input type="number" id="logo-x" min="0" />
                    <span style="font-size: 11px; color: #888">px</span>
                </div>
                <div class="context-menu-row">
                    <label>Y:</label>
                    <input type="number" id="logo-y" min="0" />
                    <span style="font-size: 11px; color: #888">px</span>
                </div>
            </div>
            <div class="context-menu-group">
                <div class="context-menu-row">
                    <label>Width:</label>
                    <input type="number" id="logo-width" min="30" />
                    <span style="font-size: 11px; color: #888">px</span>
                </div>
                <div class="context-menu-row">
                    <label>Height:</label>
                    <input type="number" id="logo-height" min="30" />
                    <span style="font-size: 11px; color: #888">px</span>
                </div>
            </div>
            <div class="context-menu-info">
                <div id="logo-edge-info"></div>
            </div>
        </div>

        <script>
            // Message data structure to track all message areas
            let messageCount = 1;
            let messageData = {
                1: {
                    text: 'MSG1',
                    // Typography
                    fontFamily: 'Arial, sans-serif',
                    capHeight: 62.5,
                    lineHeight: 1.2,
                    letterSpacing: 0,
                    wordSpacing: 0,
                    // Position
                    boxX: 50,
                    boxY: 300,
                    boxWidth: 700,
                    boxHeight: 200,
                    // Alignment
                    horizontalAlign: 'center',
                    verticalAlign: 'middle',
                    // Braille
                    brailleEnabled: true,
                    brailleHeight: 23.9,
                    brailleGap: 40
                }
            };
            let currentMessageId = 1;

            // Sign dimensions (will be updated dynamically)
            let SIGN_WIDTH = 800;
            let SIGN_HEIGHT = 800;
            let DPI = 100;

            // Custom fonts storage
            let customFonts = {};

            // Braille translator instance
            let brailleTranslator = null;
            let brailleReady = false;

            // SVG element references will be created dynamically

            // Load and inject braille font
            async function loadBrailleFont() {
                try {
                    const response = await fetch('BRAILLE.TTF');
                    const blob = await response.blob();
                    const reader = new FileReader();

                    return new Promise((resolve, reject) => {
                        reader.onload = function (event) {
                            const base64 = event.target.result;

                            // Inject braille font
                            const style = document.createElement('style');
                            style.id = 'braille-font-style';
                            style.textContent = `
                            @font-face {
                                font-family: 'Braille';
                                src: url(${base64}) format('truetype');
                                font-weight: normal;
                                font-style: normal;
                            }
                        `;
                            document.head.appendChild(style);
                            console.log('Braille font loaded successfully');
                            resolve();
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (error) {
                    console.error('Error loading braille font:', error);
                }
            }

            // Initialize braille translator
            async function initializeBraille() {
                try {
                    // Load braille font first
                    await loadBrailleFont();

                    // Wait a bit for LibLouis to load
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Try to find LibLouis in various places
                    let lou = null;

                    // Check if LiblouisEasyApi is available
                    if (typeof LiblouisEasyApi !== 'undefined') {
                        console.log('Found LiblouisEasyApi, initializing...');
                        // Check for liblouisBuild first (this is what build-no-tables-utf16.js creates)
                        if (typeof liblouisBuild !== 'undefined') {
                            console.log('Found liblouisBuild, using it for initialization');
                            lou = new LiblouisEasyApi(liblouisBuild);
                        } else if (typeof Module !== 'undefined' && Module._lou_version) {
                            console.log('Found Module with _lou_version');
                            lou = new LiblouisEasyApi(Module);
                        } else {
                            // Try without argument to use default (will auto-detect liblouisBuild)
                            console.log('Trying LiblouisEasyApi with auto-detection');
                            lou = new LiblouisEasyApi();
                        }
                    } else if (typeof liblouisBuild !== 'undefined' && liblouisBuild.ccall) {
                        console.log('Found liblouisBuild with ccall, using directly...');
                        // Try to use liblouisBuild directly
                        lou = liblouisBuild;
                    }

                    if (lou) {
                        // Set up virtual filesystem for LibLouis
                        try {
                            // Load all necessary table files including ALL dependencies
                            const tablesToLoad = [
                                'unicode.dis', // Required for Unicode braille output
                                'loweredDigits6Dots.uti', // Required by chardefs.cti
                                'latinLetterDef8Dots.uti', // Required by chardefs.cti
                                'latinLetterDef6Dots.uti', // Alternative letter definitions
                                'chardefs.cti', // Character definitions (loads after its dependencies)
                                'braille-patterns.cti', // Braille pattern definitions
                                'litdigits6Dots.uti', // Literal digits for 6-dot braille
                                'digits6Dots.uti', // Standard digits
                                'en-us-g1.ctb', // Grade 1 US English (included by g2)
                                'en-us-g2.ctb' // Grade 2 US English (main table)
                            ];

                            const tableContents = {};

                            // Load all table files
                            for (const tableName of tablesToLoad) {
                                const response = await fetch(`lib/liblouis/tables/${tableName}`);
                                if (response.ok) {
                                    tableContents[tableName] = await response.text();
                                    console.log(
                                        `Loaded table ${tableName}, size: ${tableContents[tableName].length}`
                                    );
                                }
                            }

                            // Set up the virtual filesystem
                            const FS = lou.getFilesystem();
                            if (FS) {
                                // Create tables directory in virtual filesystem root
                                try {
                                    FS.mkdir('/tables');
                                } catch (e) {
                                    // Directory might already exist
                                }

                                // Write all tables to virtual filesystem
                                for (const [name, content] of Object.entries(tableContents)) {
                                    FS.writeFile(`/tables/${name}`, content);
                                    console.log(
                                        `Wrote ${name} to virtual filesystem at /tables/${name}`
                                    );
                                }

                                // Set the data path for LibLouis to root
                                lou.setDataPath('/');
                                console.log('LibLouis data path set to /');

                                // Now try to use LibLouis with proper table path references
                                // Include unicode.dis for proper braille output
                                const tableList = 'tables/unicode.dis,tables/en-us-g2.ctb';

                                const test1 = lou.translateString(tableList, 'and');
                                const test2 = lou.translateString(tableList, 'STORAGE');

                                if (test1 && test2) {
                                    console.log('LibLouis Grade 2 tests SUCCESS:');
                                    console.log(`  "and" -> "${test1}" (Grade 2 contraction)`);
                                    console.log(`  "STORAGE" -> "${test2}"`);

                                    // Store the translator and table list for later use
                                    brailleTranslator = lou;
                                    window.liblouisTableList = tableList; // Store for use in translation
                                    brailleReady = true;
                                    console.log(
                                        'LibLouis Grade 2 translator initialized successfully!'
                                    );
                                } else {
                                    throw new Error('Translation returned null');
                                }
                            } else {
                                throw new Error('Could not get LibLouis filesystem');
                            }
                        } catch (e) {
                            console.error('Failed to initialize LibLouis properly:', e);
                            console.log('Will use fallback Grade 2 translation');
                            brailleReady = true;
                        }
                    } else {
                        console.warn('LibLouis not found, using fallback Grade 2 translation');
                        brailleReady = true;
                    }
                } catch (error) {
                    console.error('Error initializing LibLouis:', error);
                    console.log('Will use fallback Grade 2 translation');
                    brailleReady = true; // Use fallback
                }
            }

            // Simple braille character mapping (fallback)
            const simpleBrailleMap = {
                A: '⠁',
                B: '⠃',
                C: '⠉',
                D: '⠙',
                E: '⠑',
                F: '⠋',
                G: '⠛',
                H: '⠓',
                I: '⠊',
                J: '⠚',
                K: '⠅',
                L: '⠇',
                M: '⠍',
                N: '⠝',
                O: '⠕',
                P: '⠏',
                Q: '⠟',
                R: '⠗',
                S: '⠎',
                T: '⠞',
                U: '⠥',
                V: '⠧',
                W: '⠺',
                X: '⠭',
                Y: '⠽',
                Z: '⠵',
                ' ': ' ',
                1: '⠼⠁',
                2: '⠼⠃',
                3: '⠼⠉',
                4: '⠼⠙',
                5: '⠼⠑',
                6: '⠼⠋',
                7: '⠼⠛',
                8: '⠼⠓',
                9: '⠼⠊',
                0: '⠼⠚'
            };

            // Translate text to braille
            function translateToBraille(text) {
                // IMPORTANT: Convert to lowercase for ADA compliance
                // ADA signage is visually all caps, but braille should be lowercase
                const lowercaseText = text.toLowerCase();

                // Try LibLouis first for proper Grade 2
                if (
                    brailleTranslator &&
                    brailleTranslator.translateString &&
                    window.liblouisTableList
                ) {
                    try {
                        const result = brailleTranslator.translateString(
                            window.liblouisTableList,
                            lowercaseText
                        );
                        console.log(`LibLouis Grade 2: "${lowercaseText}" -> "${result}"`);
                        return result;
                    } catch (error) {
                        console.error('LibLouis translation failed:', error);
                    }
                }

                // Use JavaScript Grade 2 translation if available
                if (typeof window.translateToGrade2Braille === 'function') {
                    const result = window.translateToGrade2Braille(lowercaseText);
                    console.log(`Fallback Grade 2: "${lowercaseText}" -> "${result}"`);
                    return result;
                }

                // Last resort: simple mapping (already uses uppercase internally for mapping)
                const result = lowercaseText
                    .toUpperCase()
                    .split('')
                    .map(char => simpleBrailleMap[char] || char)
                    .join('');
                console.log(`Simple mapping: "${lowercaseText}" -> "${result}"`);
                return result;
            }

            // Load stored fonts from localStorage on startup
            function loadStoredFonts() {
                const stored = localStorage.getItem('customFonts');
                if (stored) {
                    try {
                        customFonts = JSON.parse(stored);
                        // Re-inject all stored fonts
                        Object.keys(customFonts).forEach(fontName => {
                            injectFont(fontName, customFonts[fontName]);
                            addFontToList(fontName);
                        });
                    } catch (e) {
                        console.error('Error loading stored fonts:', e);
                    }
                }
            }

            // Inject font into page
            function injectFont(fontName, base64Data) {
                const styleId = 'custom-font-' + fontName.replace(/\s+/g, '-');

                // Remove existing style if present
                const existing = document.getElementById(styleId);
                if (existing) {
                    existing.remove();
                }

                // Create new style element
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                @font-face {
                    font-family: '${fontName}';
                    src: url(${base64Data}) format('truetype');
                    font-weight: normal;
                    font-style: normal;
                }
                @font-face {
                    font-family: '${fontName}';
                    src: url(${base64Data}) format('truetype');
                    font-weight: bold;
                    font-style: normal;
                }
            `;
                document.head.appendChild(style);
            }

            // Add font to the dropdown
            function addFontToList(fontName) {
                // Add to dropdown if not already there
                const select = document.getElementById('font-family');
                const optionId = 'font-option-' + fontName.replace(/\s+/g, '-');
                if (!document.getElementById(optionId)) {
                    const option = document.createElement('option');
                    option.id = optionId;
                    option.value = `'${fontName}', sans-serif`;
                    option.textContent = fontName + ' (Custom)';
                    select.appendChild(option);
                }
            }

            // Remove font
            function removeFont(fontName) {
                // Remove from storage
                delete customFonts[fontName];
                localStorage.setItem('customFonts', JSON.stringify(customFonts));

                // Remove from page
                const styleId = 'custom-font-' + fontName.replace(/\s+/g, '-');
                const style = document.getElementById(styleId);
                if (style) style.remove();

                // Remove from dropdown
                const optionId = 'font-option-' + fontName.replace(/\s+/g, '-');
                const option = document.getElementById(optionId);
                if (option) option.remove();

                // If this was the selected font, switch to Arial
                const select = document.getElementById('font-family');
                if (select.value === `'${fontName}', sans-serif`) {
                    select.value = 'Arial, sans-serif';
                    updateText();
                }
            }

            // Use custom system font
            function useCustomFont() {
                const fontName = document.getElementById('custom-font').value.trim();
                if (!fontName) {
                    alert('Please enter a font name');
                    return;
                }

                // Add to dropdown and select it
                const select = document.getElementById('font-family');
                const optionId = 'font-option-' + fontName.replace(/\s+/g, '-');
                if (!document.getElementById(optionId)) {
                    const option = document.createElement('option');
                    option.id = optionId;
                    option.value = `'${fontName}', sans-serif`;
                    option.textContent = fontName + ' (System)';
                    select.appendChild(option);
                }

                select.value = `'${fontName}', sans-serif`;
                updateText();
            }

            // Handle font file upload
            document.addEventListener('DOMContentLoaded', async function () {
                loadStoredFonts();
                setupContextMenuHandlers();

                // Initialize braille
                await initializeBraille();

                document.getElementById('font-upload').addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const base64 = event.target.result;

                        // Extract font name from filename (remove extension)
                        let fontName = file.name.replace(/\.(ttf|otf|woff|woff2)$/i, '');

                        // Prompt for custom name
                        const customName = prompt(
                            'Font name (or leave blank to use filename):',
                            fontName
                        );
                        if (customName !== null && customName.trim()) {
                            fontName = customName.trim();
                        }

                        // Store font
                        customFonts[fontName] = base64;
                        localStorage.setItem('customFonts', JSON.stringify(customFonts));

                        // Inject and use font
                        injectFont(fontName, base64);

                        // Wait a moment for font to load, then add to list
                        setTimeout(() => {
                            addFontToList(fontName);

                            // Select the new font
                            const select = document.getElementById('font-family');
                            select.value = `'${fontName}', sans-serif`;
                            updateText();
                        }, 100);
                    };
                    reader.readAsDataURL(file);

                    // Clear the input so the same file can be re-uploaded if needed
                    e.target.value = '';
                });
            });

            // Create SVG container with zoom
            const svgContainer = d3.select('#svg-container');
            let svg = svgContainer
                .append('svg')
                .attr('width', SIGN_WIDTH)
                .attr('height', SIGN_HEIGHT)
                .attr('viewBox', `0 0 ${SIGN_WIDTH} ${SIGN_HEIGHT}`);

            // Create a group for zoomable content
            let zoomGroup = svg.append('g');

            // Set up zoom behavior
            const zoom = d3
                .zoom()
                .scaleExtent([0.1, 5]) // Min zoom 10%, max zoom 500%
                .filter(function (event) {
                    // Only allow zoom on wheel and middle mouse drag
                    if (event.type === 'wheel') {
                        event.preventDefault(); // Prevent page scroll
                        return true;
                    }
                    if (event.type === 'mousedown' && event.button === 1) return true; // Middle mouse
                    if (event.type === 'mousemove' && event.buttons === 4) return true; // Middle mouse drag
                    return false;
                })
                .on('zoom', function (event) {
                    zoomGroup.attr('transform', event.transform);
                });

            // Apply zoom behavior to SVG
            svg.call(zoom);

            // Prevent page scroll when zooming
            svg.on('wheel', function (event) {
                event.preventDefault();
            });

            // Prevent middle mouse button scrolling
            svg.on('mousedown', function (event) {
                if (event.button === 1) {
                    // Middle mouse button
                    event.preventDefault(); // Prevent default middle mouse behavior
                    return false;
                }
            });

            // Also prevent on the container
            svgContainer.on('mousedown', function (event) {
                if (event.button === 1) {
                    event.preventDefault();
                    return false;
                }
            });

            // Prevent middle mouse auto-scroll cursor
            document.getElementById('svg-container').addEventListener(
                'mousedown',
                function (e) {
                    if (e.button === 1) {
                        e.preventDefault();
                        return false;
                    }
                },
                true
            );

            // Create all SVG elements that will be redrawn
            let backgroundRect, logoGroup, textContainer, brailleContainer, rulerGroup;
            let uploadedLogoSVG = null; // Store uploaded SVG content
            let logoPosition = { x: SIGN_WIDTH - 150, y: 50, width: 100, height: 100 };
            let isDraggingLogo = false;
            let isResizingLogo = false;
            let resizeHandle = null;
            let dragOffset = { x: 0, y: 0 };
            let hasDragged = false; // Track if actual dragging occurred

            // Create logo container with upload functionality
            function createLogoContainer() {
                logoGroup = zoomGroup
                    .append('g')
                    .attr('transform', `translate(${logoPosition.x}, ${logoPosition.y})`);

                // Background container
                const logoContainer = logoGroup.append('g').attr('class', 'logo-container');

                // Add border/background
                const logoBackground = logoContainer
                    .append('rect')
                    .attr('class', 'logo-background')
                    .attr('width', logoPosition.width)
                    .attr('height', logoPosition.height)
                    .attr('fill', 'transparent')
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .style('cursor', 'pointer');

                if (!uploadedLogoSVG) {
                    // Show placeholder (orange cross) if no logo uploaded
                    const placeholderGroup = logoContainer
                        .append('g')
                        .attr('class', 'logo-placeholder');

                    // Vertical bar of cross
                    placeholderGroup
                        .append('rect')
                        .attr('x', logoPosition.width / 2 - 15)
                        .attr('y', 10)
                        .attr('width', 30)
                        .attr('height', logoPosition.height - 20)
                        .attr('fill', '#FF6B35')
                        .style('pointer-events', 'none');

                    // Horizontal bar of cross
                    placeholderGroup
                        .append('rect')
                        .attr('x', 10)
                        .attr('y', logoPosition.height / 2 - 15)
                        .attr('width', logoPosition.width - 20)
                        .attr('height', 30)
                        .attr('fill', '#FF6B35')
                        .style('pointer-events', 'none');

                    // Add "Click to Upload" text
                    placeholderGroup
                        .append('text')
                        .attr('x', logoPosition.width / 2)
                        .attr('y', logoPosition.height - 5)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '12')
                        .attr('fill', '#666')
                        .text('Click to Upload')
                        .style('pointer-events', 'none');
                } else {
                    // Display uploaded SVG
                    displayUploadedLogo(logoContainer);
                }

                // Add resize handles
                addResizeHandles(logoGroup);

                // Add click handler for upload
                logoBackground.on('click', function () {
                    if (!hasDragged && !isResizingLogo) {
                        triggerLogoUpload();
                    }
                });

                // Add right-click handler for context menu
                logoBackground.on('contextmenu', function (event) {
                    event.preventDefault();
                    showLogoContextMenu(event);
                });

                // Add drag functionality
                logoBackground.on('mousedown', function (event) {
                    if (!isResizingLogo && event.button === 0) {
                        // Left mouse button only
                        isDraggingLogo = true;
                        hasDragged = false; // Reset drag flag
                        const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());
                        dragOffset.x = mouseX - logoPosition.x;
                        dragOffset.y = mouseY - logoPosition.y;
                        event.stopPropagation();
                        // Prevent text selection during drag
                        document.body.classList.add('no-select');
                    }
                });
            }

            // Display uploaded SVG in container
            function displayUploadedLogo(container) {
                // Remove placeholder if it exists
                container.select('.logo-placeholder').remove();

                // Create a group for the SVG content
                const svgGroup = container.append('g').attr('class', 'uploaded-logo');

                // Parse and insert the SVG
                const parser = new DOMParser();
                const doc = parser.parseFromString(uploadedLogoSVG, 'image/svg+xml');
                const svgElement = doc.documentElement;

                // Get viewBox or dimensions from the original SVG
                let viewBox = svgElement.getAttribute('viewBox');
                let originalWidth, originalHeight;

                if (viewBox) {
                    const parts = viewBox.split(' ');
                    originalWidth = parseFloat(parts[2]);
                    originalHeight = parseFloat(parts[3]);
                } else {
                    originalWidth = parseFloat(svgElement.getAttribute('width')) || 100;
                    originalHeight = parseFloat(svgElement.getAttribute('height')) || 100;
                }

                // Calculate scale to fit container
                const scaleX = logoPosition.width / originalWidth;
                const scaleY = logoPosition.height / originalHeight;

                // Apply transform to fit and stretch
                svgGroup.attr('transform', `scale(${scaleX}, ${scaleY})`);

                // Copy all children from uploaded SVG
                Array.from(svgElement.children).forEach(child => {
                    const d3Node = d3.select(svgGroup.node()).append(() => child.cloneNode(true));
                });

                // Make sure pointer events work
                svgGroup.style('pointer-events', 'none');
            }

            // Add resize handles to logo container
            function addResizeHandles(group) {
                const handleSize = 10;
                const handles = [
                    { name: 'nw', x: 0, y: 0, cursor: 'nw-resize' },
                    { name: 'ne', x: logoPosition.width, y: 0, cursor: 'ne-resize' },
                    { name: 'sw', x: 0, y: logoPosition.height, cursor: 'sw-resize' },
                    {
                        name: 'se',
                        x: logoPosition.width,
                        y: logoPosition.height,
                        cursor: 'se-resize'
                    },
                    { name: 'n', x: logoPosition.width / 2, y: 0, cursor: 'n-resize' },
                    {
                        name: 's',
                        x: logoPosition.width / 2,
                        y: logoPosition.height,
                        cursor: 's-resize'
                    },
                    { name: 'w', x: 0, y: logoPosition.height / 2, cursor: 'w-resize' },
                    {
                        name: 'e',
                        x: logoPosition.width,
                        y: logoPosition.height / 2,
                        cursor: 'e-resize'
                    }
                ];

                handles.forEach(handle => {
                    group
                        .append('rect')
                        .attr('class', `resize-handle handle-${handle.name}`)
                        .attr('x', handle.x - handleSize / 2)
                        .attr('y', handle.y - handleSize / 2)
                        .attr('width', handleSize)
                        .attr('height', handleSize)
                        .attr('fill', '#003875')
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1)
                        .style('cursor', handle.cursor)
                        .on('mousedown', function (event) {
                            isResizingLogo = true;
                            resizeHandle = handle.name;
                            event.stopPropagation();
                            // Prevent text selection during resize
                            document.body.classList.add('no-select');
                        });
                });
            }

            // Show logo context menu
            function showLogoContextMenu(event) {
                const menu = document.getElementById('logo-context-menu');

                // Position menu at cursor
                menu.style.left = event.clientX + 'px';
                menu.style.top = event.clientY + 'px';

                // Update input values with current logo position/size
                document.getElementById('logo-x').value = Math.round(logoPosition.x);
                document.getElementById('logo-y').value = Math.round(logoPosition.y);
                document.getElementById('logo-width').value = Math.round(logoPosition.width);
                document.getElementById('logo-height').value = Math.round(logoPosition.height);

                // Calculate distances from edges
                const rightEdge = SIGN_WIDTH - (logoPosition.x + logoPosition.width);
                const bottomEdge = SIGN_HEIGHT - (logoPosition.y + logoPosition.height);

                // Update edge info
                document.getElementById('logo-edge-info').innerHTML = `
                    Distances from edges:<br>
                    Top: ${Math.round(logoPosition.y)}px |
                    Right: ${Math.round(rightEdge)}px<br>
                    Bottom: ${Math.round(bottomEdge)}px |
                    Left: ${Math.round(logoPosition.x)}px
                `;

                // Show menu
                menu.classList.add('show');

                // Prevent menu from going off-screen
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = window.innerWidth - rect.width - 10 + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = window.innerHeight - rect.height - 10 + 'px';
                }
            }

            // Hide logo context menu
            function hideLogoContextMenu() {
                document.getElementById('logo-context-menu').classList.remove('show');
            }

            // Setup context menu input handlers
            function setupContextMenuHandlers() {
                // X position
                document.getElementById('logo-x').addEventListener('input', function () {
                    logoPosition.x = parseInt(this.value) || 0;
                    updateLogoTransform();
                });

                // Y position
                document.getElementById('logo-y').addEventListener('input', function () {
                    logoPosition.y = parseInt(this.value) || 0;
                    updateLogoTransform();
                });

                // Width
                document.getElementById('logo-width').addEventListener('input', function () {
                    logoPosition.width = Math.max(30, parseInt(this.value) || 30);
                    updateLogoTransform();
                });

                // Height
                document.getElementById('logo-height').addEventListener('input', function () {
                    logoPosition.height = Math.max(30, parseInt(this.value) || 30);
                    updateLogoTransform();
                });

                // Close menu on click away
                document.addEventListener('click', function (event) {
                    const menu = document.getElementById('logo-context-menu');
                    if (!menu.contains(event.target) && !event.target.closest('.logo-background')) {
                        hideLogoContextMenu();
                    }
                });

                // Close on Escape key
                document.addEventListener('keydown', function (event) {
                    if (event.key === 'Escape') {
                        hideLogoContextMenu();
                    }
                });
            }

            // Trigger file upload dialog
            function triggerLogoUpload() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.svg,image/svg+xml';
                input.onchange = function (e) {
                    const file = e.target.files[0];
                    if (file && file.type === 'image/svg+xml') {
                        const reader = new FileReader();
                        reader.onload = function (event) {
                            uploadedLogoSVG = event.target.result;
                            // Recreate logo container with uploaded SVG
                            logoGroup.remove();
                            createLogoContainer();
                        };
                        reader.readAsText(file);
                    } else {
                        alert('Please upload an SVG file');
                    }
                };
                input.click();
            }

            // Update logo position and size
            function updateLogoTransform() {
                logoGroup.attr('transform', `translate(${logoPosition.x}, ${logoPosition.y})`);

                // Update background rect
                logoGroup
                    .select('.logo-background')
                    .attr('width', logoPosition.width)
                    .attr('height', logoPosition.height);

                // Update placeholder if no logo uploaded
                if (!uploadedLogoSVG) {
                    const placeholder = logoGroup.select('.logo-placeholder');
                    placeholder
                        .select('rect:nth-child(1)')
                        .attr('x', logoPosition.width / 2 - 15)
                        .attr('height', logoPosition.height - 20);

                    placeholder
                        .select('rect:nth-child(2)')
                        .attr('y', logoPosition.height / 2 - 15)
                        .attr('width', logoPosition.width - 20);

                    placeholder
                        .select('text')
                        .attr('x', logoPosition.width / 2)
                        .attr('y', logoPosition.height - 5);
                } else {
                    // Re-render uploaded logo with new dimensions
                    logoGroup.select('.logo-container').select('.uploaded-logo').remove();
                    displayUploadedLogo(logoGroup.select('.logo-container'));
                }

                // Update resize handles
                const handles = [
                    { name: 'nw', x: 0, y: 0 },
                    { name: 'ne', x: logoPosition.width, y: 0 },
                    { name: 'sw', x: 0, y: logoPosition.height },
                    { name: 'se', x: logoPosition.width, y: logoPosition.height },
                    { name: 'n', x: logoPosition.width / 2, y: 0 },
                    { name: 's', x: logoPosition.width / 2, y: logoPosition.height },
                    { name: 'w', x: 0, y: logoPosition.height / 2 },
                    { name: 'e', x: logoPosition.width, y: logoPosition.height / 2 }
                ];

                handles.forEach(handle => {
                    logoGroup
                        .select(`.handle-${handle.name}`)
                        .attr('x', handle.x - 5)
                        .attr('y', handle.y - 5);
                });
            }

            // Add mouse move and mouse up handlers for dragging and resizing
            d3.select(document).on('mousemove', function (event) {
                if (isDraggingLogo) {
                    hasDragged = true; // Set flag when actual dragging occurs
                    const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());
                    logoPosition.x = mouseX - dragOffset.x;
                    logoPosition.y = mouseY - dragOffset.y;

                    // Keep logo within bounds
                    logoPosition.x = Math.max(
                        0,
                        Math.min(SIGN_WIDTH - logoPosition.width, logoPosition.x)
                    );
                    logoPosition.y = Math.max(
                        0,
                        Math.min(SIGN_HEIGHT - logoPosition.height, logoPosition.y)
                    );

                    updateLogoTransform();
                } else if (isResizingLogo) {
                    const [mouseX, mouseY] = d3.pointer(event, zoomGroup.node());

                    // Store original aspect ratio
                    const aspectRatio = logoPosition.width / logoPosition.height;

                    // Handle corner resizes (maintain aspect ratio)
                    if (resizeHandle === 'se') {
                        // Southeast corner - anchor at northwest (top-left stays fixed)
                        const newWidth = Math.max(30, mouseX - logoPosition.x);
                        const newHeight = Math.max(30, mouseY - logoPosition.y);

                        // Use diagonal distance to determine scale
                        const distX = mouseX - logoPosition.x;
                        const distY = mouseY - logoPosition.y;
                        const diagonal = Math.sqrt(distX * distX + distY * distY);
                        const originalDiagonal = Math.sqrt(
                            logoPosition.width * logoPosition.width +
                                logoPosition.height * logoPosition.height
                        );

                        // Scale based on mouse position along diagonal
                        if (distX / aspectRatio > distY) {
                            logoPosition.width = newWidth;
                            logoPosition.height = newWidth / aspectRatio;
                        } else {
                            logoPosition.height = newHeight;
                            logoPosition.width = newHeight * aspectRatio;
                        }
                    } else if (resizeHandle === 'sw') {
                        // Southwest corner - anchor at northeast (top-right stays fixed)
                        const anchorX = logoPosition.x + logoPosition.width;
                        const newWidth = Math.max(30, anchorX - mouseX);
                        const newHeight = Math.max(30, mouseY - logoPosition.y);

                        if (newWidth / aspectRatio > newHeight) {
                            logoPosition.width = newWidth;
                            logoPosition.height = newWidth / aspectRatio;
                            logoPosition.x = anchorX - newWidth;
                        } else {
                            logoPosition.height = newHeight;
                            logoPosition.width = newHeight * aspectRatio;
                            logoPosition.x = anchorX - newHeight * aspectRatio;
                        }
                    } else if (resizeHandle === 'ne') {
                        // Northeast corner - anchor at southwest (bottom-left stays fixed)
                        const anchorY = logoPosition.y + logoPosition.height;
                        const newWidth = Math.max(30, mouseX - logoPosition.x);
                        const newHeight = Math.max(30, anchorY - mouseY);

                        if (newWidth / aspectRatio > newHeight) {
                            logoPosition.width = newWidth;
                            logoPosition.height = newWidth / aspectRatio;
                            logoPosition.y = anchorY - newWidth / aspectRatio;
                        } else {
                            logoPosition.height = newHeight;
                            logoPosition.width = newHeight * aspectRatio;
                            logoPosition.y = anchorY - newHeight;
                        }
                    } else if (resizeHandle === 'nw') {
                        // Northwest corner - anchor at southeast (bottom-right stays fixed)
                        const anchorX = logoPosition.x + logoPosition.width;
                        const anchorY = logoPosition.y + logoPosition.height;
                        const newWidth = Math.max(30, anchorX - mouseX);
                        const newHeight = Math.max(30, anchorY - mouseY);

                        if (newWidth / aspectRatio > newHeight) {
                            logoPosition.width = newWidth;
                            logoPosition.height = newWidth / aspectRatio;
                            logoPosition.x = anchorX - newWidth;
                            logoPosition.y = anchorY - newWidth / aspectRatio;
                        } else {
                            logoPosition.height = newHeight;
                            logoPosition.width = newHeight * aspectRatio;
                            logoPosition.x = anchorX - newHeight * aspectRatio;
                            logoPosition.y = anchorY - newHeight;
                        }
                    }
                    // Handle edge resizes (allow stretching)
                    else if (resizeHandle === 'e') {
                        logoPosition.width = Math.max(30, mouseX - logoPosition.x);
                    } else if (resizeHandle === 'w') {
                        const newWidth = Math.max(30, logoPosition.x + logoPosition.width - mouseX);
                        logoPosition.x = logoPosition.x + logoPosition.width - newWidth;
                        logoPosition.width = newWidth;
                    } else if (resizeHandle === 's') {
                        logoPosition.height = Math.max(30, mouseY - logoPosition.y);
                    } else if (resizeHandle === 'n') {
                        const newHeight = Math.max(
                            30,
                            logoPosition.y + logoPosition.height - mouseY
                        );
                        logoPosition.y = logoPosition.y + logoPosition.height - newHeight;
                        logoPosition.height = newHeight;
                    }

                    updateLogoTransform();
                }
            });

            d3.select(document).on('mouseup', function () {
                isDraggingLogo = false;
                isResizingLogo = false;
                resizeHandle = null;
                // Re-enable text selection
                document.body.classList.remove('no-select');
            });

            function initializeSVG() {
                // Clear zoomable content (but keep zoom group)
                zoomGroup.selectAll('*').remove();

                // Get current color values
                const signColor = document.getElementById('sign-color').value;

                // Add background (sign plate)
                backgroundRect = zoomGroup
                    .append('rect')
                    .attr('class', 'sign-background')
                    .attr('width', SIGN_WIDTH)
                    .attr('height', SIGN_HEIGHT)
                    .attr('fill', signColor)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 3);

                // Add interactive logo container
                createLogoContainer();

                // We'll create text area rectangles and labels dynamically in renderAllMessages()

                // Create text container
                textContainer = zoomGroup.append('g').attr('id', 'sign-text-container');

                // Create braille container
                brailleContainer = zoomGroup.append('g').attr('id', 'braille-container');

                // Add measurement rulers
                rulerGroup = zoomGroup.append('g').attr('id', 'rulers');

                const showRulers = document.getElementById('show-rulers').checked;
                rulerGroup.style('display', showRulers ? 'block' : 'none');

                // Horizontal ruler
                rulerGroup
                    .append('line')
                    .attr('x1', 0)
                    .attr('y1', 30)
                    .attr('x2', SIGN_WIDTH)
                    .attr('y2', 30)
                    .attr('stroke', '#ff0000')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.7);

                rulerGroup
                    .append('text')
                    .attr('x', SIGN_WIDTH / 2)
                    .attr('y', 20)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', 14)
                    .attr('font-weight', 'bold')
                    .attr('fill', '#ff0000')
                    .text(
                        `${(SIGN_WIDTH / DPI).toFixed(2)} inches (${SIGN_WIDTH}px at ${DPI} DPI)`
                    );

                // Vertical ruler
                rulerGroup
                    .append('line')
                    .attr('x1', 30)
                    .attr('y1', 0)
                    .attr('x2', 30)
                    .attr('y2', SIGN_HEIGHT)
                    .attr('stroke', '#ff0000')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.7);

                rulerGroup
                    .append('text')
                    .attr('x', 40)
                    .attr('y', SIGN_HEIGHT / 2)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', 14)
                    .attr('font-weight', 'bold')
                    .attr('fill', '#ff0000')
                    .attr('transform', `rotate(-90, 40, ${SIGN_HEIGHT / 2})`)
                    .text(`${(SIGN_HEIGHT / DPI).toFixed(2)} inches (${SIGN_HEIGHT}px)`);
            }

            // Initialize SVG
            initializeSVG();

            // Manual text wrapping function
            function wrapText(
                text,
                fontFamily,
                fontSize,
                letterSpacing,
                wordSpacing,
                maxWidth,
                maxHeight
            ) {
                // Create invisible text element for measuring
                const measurer = svg
                    .append('text')
                    .style('font-family', fontFamily)
                    .style('font-size', fontSize + 'px')
                    .style('font-weight', 'bold')
                    .style('letter-spacing', letterSpacing + 'px')
                    .style('word-spacing', wordSpacing + 'px')
                    .style('visibility', 'hidden');

                // Split text by newlines first (manual line breaks)
                const paragraphs = text.split('\n');
                const allLines = [];

                // Process each paragraph
                paragraphs.forEach(paragraph => {
                    if (paragraph.trim() === '') {
                        allLines.push(''); // Preserve empty lines
                        return;
                    }

                    const words = paragraph.trim().split(/\s+/);
                    let currentLine = [];

                    words.forEach(word => {
                        currentLine.push(word);
                        measurer.text(currentLine.join(' '));
                        const lineWidth = measurer.node().getComputedTextLength();

                        if (lineWidth > maxWidth && currentLine.length > 1) {
                            // Line is too long, remove last word and start new line
                            currentLine.pop();
                            allLines.push(currentLine.join(' '));
                            currentLine = [word];
                        }
                    });

                    // Add remaining words
                    if (currentLine.length > 0) {
                        allLines.push(currentLine.join(' '));
                    }
                });

                // Remove measurer
                measurer.remove();

                return allLines;
            }

            // Function to update sign dimensions
            function updateSignDimensions() {
                SIGN_WIDTH = parseInt(document.getElementById('sign-width').value);
                SIGN_HEIGHT = parseInt(document.getElementById('sign-height').value);
                DPI = parseInt(document.getElementById('sign-dpi').value);

                // Calculate inch dimensions for display
                const signWidthInches = (SIGN_WIDTH / DPI).toFixed(2);
                const signHeightInches = (SIGN_HEIGHT / DPI).toFixed(2);

                // Update SVG dimensions
                svg.attr('width', SIGN_WIDTH)
                    .attr('height', SIGN_HEIGHT)
                    .attr('viewBox', `0 0 ${SIGN_WIDTH} ${SIGN_HEIGHT}`);

                // Redraw SVG elements
                initializeSVG();

                // Update display info (removed since we removed the info divs)
                // document.getElementById('dpi-display').textContent = DPI;
                // document.getElementById('ada-size').textContent = (0.625 * DPI).toFixed(1);
                // document.getElementById('sign-size-display').textContent =
                //     `${SIGN_WIDTH}x${SIGN_HEIGHT}`;
                // document.getElementById('sign-inches-display').textContent =
                //     `${signWidthInches}" x ${signHeightInches}"`;

                // Update text
                updateText();
            }

            // Function to measure actual cap height
            function measureCapHeight(fontFamily, fontSize) {
                // Create a temporary canvas to measure text metrics
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = `bold ${fontSize}px ${fontFamily}`;

                // Measure an 'X' to get cap height
                const metrics = ctx.measureText('X');

                // Get the actual bounds if available (not all browsers support this)
                let capHeight;
                if (metrics.actualBoundingBoxAscent) {
                    capHeight = metrics.actualBoundingBoxAscent;
                } else {
                    // Fallback: estimate cap height as 72% of font size (typical ratio)
                    capHeight = fontSize * 0.72;
                }

                return capHeight;
            }

            // Function to calculate font-size needed for desired cap height
            function calculateFontSizeForCapHeight(fontFamily, targetCapHeight) {
                // Start with an estimate (cap height is typically 70-75% of font size)
                let fontSize = targetCapHeight / 0.72;
                let iterations = 0;
                const maxIterations = 10;

                // Refine the estimate iteratively
                while (iterations < maxIterations) {
                    const measuredCapHeight = measureCapHeight(fontFamily, fontSize);
                    const error = targetCapHeight - measuredCapHeight;

                    // If we're close enough, return
                    if (Math.abs(error) < 0.1) {
                        return fontSize;
                    }

                    // Adjust font size proportionally
                    fontSize = fontSize * (targetCapHeight / measuredCapHeight);
                    iterations++;
                }

                return fontSize;
            }

            // Function to measure actual braille dot height
            function measureBrailleDotHeight(fontSize) {
                // Create a temporary canvas to measure braille characters
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = `${fontSize}px Braille`;

                // Measure a full braille cell (⠿ has all dots filled)
                const metrics = ctx.measureText('⠿');

                // Get the actual bounds if available
                let dotHeight;
                if (metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent) {
                    dotHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                } else {
                    // Fallback: estimate dot height as 62% of font size
                    dotHeight = fontSize * 0.62;
                }

                return dotHeight;
            }

            // Function to calculate font-size needed for desired braille dot height
            function calculateBrailleFontSize(targetDotHeight) {
                // Start with an estimate
                let fontSize = targetDotHeight / 0.62;
                let iterations = 0;
                const maxIterations = 10;

                // Refine the estimate iteratively
                while (iterations < maxIterations) {
                    const measuredDotHeight = measureBrailleDotHeight(fontSize);
                    const error = targetDotHeight - measuredDotHeight;

                    // If we're close enough, return
                    if (Math.abs(error) < 0.1) {
                        return fontSize;
                    }

                    // Adjust font size proportionally
                    fontSize = fontSize * (targetDotHeight / measuredDotHeight);
                    iterations++;
                }

                return fontSize;
            }

            // Function to update text
            function updateText() {
                // Save current message data
                saveCurrentMessageData();

                // Render all messages
                renderAllMessages();
            }

            // Function to render all message areas
            function renderAllMessages() {
                // Clear all containers
                textContainer.selectAll('*').remove();
                brailleContainer.selectAll('*').remove();

                // Get global color values (these remain global for all messages)
                const textColor = document.getElementById('text-color').value;
                const brailleColor = document.getElementById('braille-color').value;

                // Loop through all message areas
                Object.keys(messageData).forEach(msgId => {
                    const msgData = messageData[msgId];
                    const text = msgData.text;
                    const boxWidth = msgData.boxWidth;
                    const boxHeight = msgData.boxHeight;
                    const textX = msgData.boxX;
                    const textY = msgData.boxY;

                    // Use per-message typography settings
                    const fontFamily = msgData.fontFamily || 'Arial, sans-serif';
                    const targetCapHeight = msgData.capHeight || 62.5;
                    const lineHeight = msgData.lineHeight || 1.2;
                    const letterSpacing = msgData.letterSpacing || 0;
                    const wordSpacing = msgData.wordSpacing || 0;
                    const hAlign = msgData.horizontalAlign || 'center';
                    const vAlign = msgData.verticalAlign || 'middle';

                    // Calculate the font-size needed for the target cap height
                    const fontSize = calculateFontSizeForCapHeight(fontFamily, targetCapHeight);

                    // Draw text area rectangle
                    const textAreaRect = textContainer
                        .append('rect')
                        .attr('class', 'text-area-rect')
                        .attr('x', textX)
                        .attr('y', textY)
                        .attr('width', boxWidth)
                        .attr('height', boxHeight)
                        .attr('fill', 'none')
                        .attr('stroke', '#003875')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5')
                        .attr('opacity', 0.3);

                    // Create label group for this message
                    const msgLabelGroup = textContainer
                        .append('g')
                        .attr('class', 'text-area-label-group');

                    // Add background rect for label
                    msgLabelGroup
                        .append('rect')
                        .attr('x', textX)
                        .attr('y', textY)
                        .attr('width', 45)
                        .attr('height', 20)
                        .attr('fill', '#003875')
                        .attr('opacity', 0.9);

                    // Add MSG label text
                    msgLabelGroup
                        .append('text')
                        .attr('x', textX + 22.5)
                        .attr('y', textY + 14)
                        .attr('text-anchor', 'middle')
                        .attr('font-family', 'Arial, sans-serif')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .attr('fill', 'white')
                        .text('MSG' + msgId)
                        .style('pointer-events', 'none');

                    // Make all message labels draggable
                    msgLabelGroup.style('cursor', 'move').call(
                        d3
                            .drag()
                            .on('start', function (event) {
                                textAreaRect.attr('stroke-width', 3);
                                // Switch to this message's tab if not already selected
                                if (parseInt(msgId) !== currentMessageId) {
                                    // Find and click the corresponding tab button
                                    const tabButtons = document.querySelectorAll('.tab-button');
                                    tabButtons.forEach(button => {
                                        if (button.textContent === 'MSG' + msgId) {
                                            button.click();
                                        }
                                    });
                                }
                            })
                            .on('drag', function (event) {
                                const newX = Math.max(0, Math.min(SIGN_WIDTH - boxWidth, event.x));
                                const newY = Math.max(
                                    0,
                                    Math.min(SIGN_HEIGHT - boxHeight, event.y)
                                );
                                messageData[msgId].boxX = Math.round(newX);
                                messageData[msgId].boxY = Math.round(newY);
                                // Update input fields - need to update the correct tab's inputs
                                if (parseInt(msgId) === currentMessageId) {
                                    if (currentMessageId === 1) {
                                        document.getElementById('box-x').value = Math.round(newX);
                                        document.getElementById('box-y').value = Math.round(newY);
                                    } else {
                                        const tabElement = document.getElementById(
                                            'msg-' + currentMessageId + '-tab'
                                        );
                                        if (tabElement) {
                                            tabElement.querySelector('#box-x').value =
                                                Math.round(newX);
                                            tabElement.querySelector('#box-y').value =
                                                Math.round(newY);
                                        }
                                    }
                                }
                                renderAllMessages();
                            })
                            .on('end', function (event) {
                                textAreaRect.attr('stroke-width', 2);
                            })
                    );

                    // Wrap text for this message
                    const lines = wrapText(
                        text,
                        fontFamily,
                        fontSize,
                        letterSpacing,
                        wordSpacing,
                        boxWidth,
                        boxHeight
                    );

                    // Calculate vertical position based on alignment
                    const lineHeightPx = fontSize * lineHeight;
                    const totalTextHeight = lines.length * lineHeightPx;

                    let startY;
                    let verticalPadding = 0; // Initialize for debug info
                    if (vAlign === 'top') {
                        startY = textY + fontSize; // Top aligned
                        verticalPadding = 0;
                    } else if (vAlign === 'bottom') {
                        startY = textY + boxHeight - totalTextHeight + fontSize;
                        verticalPadding = boxHeight - totalTextHeight;
                    } else {
                        // middle
                        verticalPadding = (boxHeight - totalTextHeight) / 2;
                        startY = textY + verticalPadding + fontSize;
                    }

                    // Calculate horizontal position based on alignment
                    let textAnchor, xPos;
                    if (hAlign === 'left') {
                        textAnchor = 'start';
                        xPos = textX;
                    } else if (hAlign === 'right') {
                        textAnchor = 'end';
                        xPos = textX + boxWidth;
                    } else {
                        // center
                        textAnchor = 'middle';
                        xPos = textX + boxWidth / 2;
                    }

                    // Render each line
                    let lastTextY = startY;
                    lines.forEach((line, i) => {
                        const y = startY + i * lineHeightPx;
                        textContainer
                            .append('text')
                            .attr('x', xPos)
                            .attr('y', y)
                            .attr('text-anchor', textAnchor)
                            .attr('font-family', fontFamily)
                            .attr('font-size', fontSize)
                            .attr('font-weight', 'bold')
                            .attr('fill', textColor)
                            .style('letter-spacing', letterSpacing + 'px')
                            .style('word-spacing', wordSpacing + 'px')
                            .text(line);
                        lastTextY = y;
                    });

                    // Add braille if enabled for this message
                    if (msgData.brailleEnabled && brailleReady) {
                        // Use per-message braille settings
                        const brailleGap = msgData.brailleGap || 40;
                        const brailleTargetHeight = msgData.brailleHeight || 23.9;

                        // Calculate font-size needed to achieve exact braille dot height
                        const brailleFontSize = calculateBrailleFontSize(brailleTargetHeight);

                        // Verify actual height achieved
                        const actualBrailleHeight = measureBrailleDotHeight(brailleFontSize);
                        console.log(
                            `Braille: target ${brailleTargetHeight.toFixed(1)}px, actual ${actualBrailleHeight.toFixed(1)}px, font-size ${brailleFontSize.toFixed(1)}px`
                        );

                        const brailleY = lastTextY + brailleGap + brailleTargetHeight; // Top of braille + height for baseline

                        // Translate text to braille - remove newlines so it flows continuously
                        const textWithoutBreaks = text.replace(/\n/g, ' ');
                        const brailleText = translateToBraille(textWithoutBreaks);

                        // Wrap braille text to fit within sign width
                        const brailleMeasurer = document.createElement('div');
                        brailleMeasurer.style.position = 'absolute';
                        brailleMeasurer.style.visibility = 'hidden';
                        brailleMeasurer.style.fontFamily = 'Braille, monospace';
                        brailleMeasurer.style.fontSize = brailleFontSize + 'px';
                        brailleMeasurer.style.whiteSpace = 'nowrap';
                        document.body.appendChild(brailleMeasurer);

                        // Simple word wrapping for braille
                        const brailleWords = brailleText.split(' ');
                        const brailleLines = [];
                        let currentBrailleLine = [];

                        brailleWords.forEach(word => {
                            currentBrailleLine.push(word);
                            brailleMeasurer.textContent = currentBrailleLine.join(' ');
                            const lineWidth = brailleMeasurer.offsetWidth;

                            if (lineWidth > boxWidth && currentBrailleLine.length > 1) {
                                currentBrailleLine.pop();
                                brailleLines.push(currentBrailleLine.join(' '));
                                currentBrailleLine = [word];
                            }
                        });

                        if (currentBrailleLine.length > 0) {
                            brailleLines.push(currentBrailleLine.join(' '));
                        }

                        brailleMeasurer.remove();

                        // Render braille lines
                        brailleLines.forEach((line, i) => {
                            brailleContainer
                                .append('text')
                                .attr('x', xPos) // Use same horizontal position as main text
                                .attr('y', brailleY + i * brailleTargetHeight * 1.5) // 1.5 line height for braille spacing
                                .attr('text-anchor', textAnchor) // Use same text anchor as main text
                                .attr('font-family', 'Braille, monospace')
                                .attr('font-size', brailleFontSize)
                                .attr('fill', brailleColor)
                                .text(line);
                        });

                        // Add visual indicator for braille area (dotted outline)
                        const brailleTotalHeight = Math.max(
                            brailleLines.length * brailleTargetHeight * 1.5,
                            brailleTargetHeight * 1.5
                        );
                        brailleContainer
                            .append('rect')
                            .attr('x', textX)
                            .attr('y', brailleY - brailleTargetHeight)
                            .attr('width', boxWidth)
                            .attr('height', brailleTotalHeight + 5)
                            .attr('fill', 'none')
                            .attr('stroke', '#6a1b9a')
                            .attr('stroke-width', 1)
                            .attr('stroke-dasharray', '3,3')
                            .attr('opacity', 0.3);
                    }
                }); // End forEach loop for messages

                // Update debug info with current message data
                if (currentMessageId && messageData[currentMessageId]) {
                    const currentData = messageData[currentMessageId];
                    const debugInfo = document.getElementById('debug-info');
                    debugInfo.innerHTML = `
                    Current Message: MSG${currentMessageId}<br>
                    Font Size: ${fontSize}px (${(fontSize / 100).toFixed(3)}" at 100 DPI)<br>
                    Text Area: ${currentData.boxWidth}x${currentData.boxHeight}px<br>
                    Position: (${currentData.boxX}, ${currentData.boxY})<br>
                    Total Messages: ${Object.keys(messageData).length}
                `;
                }
            }

            // Function to set preset text
            function setPreset(text) {
                document.getElementById('sign-text').value = text;
                updateText();
            }

            // Function to switch tabs
            function switchTab(tabName, buttonElement) {
                // Save current message data before switching
                if (currentMessageId && tabName !== 'dimensions') {
                    saveCurrentMessageData();
                }

                // Hide all tab contents
                document.querySelectorAll('.tab-content').forEach(tab => {
                    tab.classList.remove('active');
                });

                // Remove active class from all tab buttons
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.classList.remove('active');
                });

                // Show selected tab content
                document.getElementById(tabName + '-tab').classList.add('active');

                // Add active class to clicked button
                // If buttonElement is provided, use it; otherwise try event.target
                const activeButton = buttonElement || event.target;
                if (activeButton) {
                    activeButton.classList.add('active');
                }

                // If switching to a message tab, load its data
                if (tabName.startsWith('msg-')) {
                    const msgId = parseInt(tabName.split('-')[1]);
                    loadMessageData(msgId);
                }
            }

            // Function to save current message data
            function saveCurrentMessageData() {
                if (!currentMessageId) return;

                // Get the current tab's elements
                const currentTab = document.getElementById('msg-' + currentMessageId + '-tab');

                // For MSG1, use getElementById; for others, query within the tab
                if (currentMessageId === 1) {
                    messageData[currentMessageId] = {
                        text: document.getElementById('sign-text').value,
                        // Typography settings
                        fontFamily: document.getElementById('font-family').value,
                        capHeight: parseFloat(document.getElementById('cap-height').value),
                        lineHeight: parseFloat(document.getElementById('line-height').value),
                        letterSpacing: parseFloat(document.getElementById('letter-spacing').value),
                        wordSpacing: parseFloat(document.getElementById('word-spacing').value),
                        // Position and dimensions
                        boxX: parseInt(document.getElementById('box-x').value),
                        boxY: parseInt(document.getElementById('box-y').value),
                        boxWidth: parseInt(document.getElementById('box-width').value),
                        boxHeight: parseInt(document.getElementById('box-height').value),
                        // Alignment
                        horizontalAlign: document.getElementById('text-h-align').value,
                        verticalAlign: document.getElementById('text-v-align').value,
                        // Braille settings
                        brailleEnabled: document.getElementById('enable-braille').checked,
                        brailleHeight:
                            parseFloat(document.getElementById('braille-height').value) || 23.9,
                        brailleGap: parseFloat(document.getElementById('braille-gap').value) || 40
                    };
                } else if (currentTab) {
                    messageData[currentMessageId] = {
                        text: currentTab.querySelector('#sign-text').value,
                        // Typography settings
                        fontFamily: currentTab.querySelector('#font-family').value,
                        capHeight: parseFloat(currentTab.querySelector('#cap-height').value),
                        lineHeight: parseFloat(currentTab.querySelector('#line-height').value),
                        letterSpacing: parseFloat(
                            currentTab.querySelector('#letter-spacing').value
                        ),
                        wordSpacing: parseFloat(currentTab.querySelector('#word-spacing').value),
                        // Position and dimensions
                        boxX: parseInt(currentTab.querySelector('#box-x').value),
                        boxY: parseInt(currentTab.querySelector('#box-y').value),
                        boxWidth: parseInt(currentTab.querySelector('#box-width').value),
                        boxHeight: parseInt(currentTab.querySelector('#box-height').value),
                        // Alignment
                        horizontalAlign: currentTab.querySelector('#text-h-align').value,
                        verticalAlign: currentTab.querySelector('#text-v-align').value,
                        // Braille settings
                        brailleEnabled: currentTab.querySelector('#enable-braille').checked,
                        brailleHeight:
                            parseFloat(currentTab.querySelector('#braille-height').value) || 23.9,
                        brailleGap: parseFloat(currentTab.querySelector('#braille-gap').value) || 40
                    };
                }
            }

            // Function to load message data
            function loadMessageData(msgId) {
                currentMessageId = msgId;
                const data = messageData[msgId];

                if (data) {
                    // Get the current tab's elements
                    const currentTab = document.getElementById('msg-' + msgId + '-tab');

                    // For MSG1, use getElementById; for others, query within the tab
                    if (msgId === 1) {
                        document.getElementById('sign-text').value = data.text;
                        // Typography
                        document.getElementById('font-family').value =
                            data.fontFamily || 'Arial, sans-serif';
                        document.getElementById('cap-height').value = data.capHeight || 62.5;
                        document.getElementById('line-height').value = data.lineHeight || 1.2;
                        document.getElementById('letter-spacing').value = data.letterSpacing || 0;
                        document.getElementById('word-spacing').value = data.wordSpacing || 0;
                        // Position
                        document.getElementById('box-x').value = data.boxX;
                        document.getElementById('box-y').value = data.boxY;
                        document.getElementById('box-width').value = data.boxWidth;
                        document.getElementById('box-height').value = data.boxHeight;
                        // Alignment
                        document.getElementById('text-h-align').value =
                            data.horizontalAlign || 'center';
                        document.getElementById('text-v-align').value =
                            data.verticalAlign || 'middle';
                        // Braille
                        document.getElementById('enable-braille').checked = data.brailleEnabled;
                        document.getElementById('braille-height').value = data.brailleHeight;
                        document.getElementById('braille-gap').value = data.brailleGap;
                    } else if (currentTab) {
                        currentTab.querySelector('#sign-text').value = data.text;
                        // Typography
                        currentTab.querySelector('#font-family').value =
                            data.fontFamily || 'Arial, sans-serif';
                        currentTab.querySelector('#cap-height').value = data.capHeight || 62.5;
                        currentTab.querySelector('#line-height').value = data.lineHeight || 1.2;
                        currentTab.querySelector('#letter-spacing').value = data.letterSpacing || 0;
                        currentTab.querySelector('#word-spacing').value = data.wordSpacing || 0;
                        // Position
                        currentTab.querySelector('#box-x').value = data.boxX;
                        currentTab.querySelector('#box-y').value = data.boxY;
                        currentTab.querySelector('#box-width').value = data.boxWidth;
                        currentTab.querySelector('#box-height').value = data.boxHeight;
                        // Alignment
                        currentTab.querySelector('#text-h-align').value =
                            data.horizontalAlign || 'center';
                        currentTab.querySelector('#text-v-align').value =
                            data.verticalAlign || 'middle';
                        // Braille
                        currentTab.querySelector('#enable-braille').checked = data.brailleEnabled;
                        currentTab.querySelector('#braille-height').value = data.brailleHeight;
                        currentTab.querySelector('#braille-gap').value = data.brailleGap;
                    }
                    updateText();
                }
            }

            // Function to find the next available MSG number
            function findNextMsgNumber() {
                let msgNum = 1;
                while (messageData[msgNum]) {
                    msgNum++;
                }
                return msgNum;
            }

            // Function to reorder tabs
            function reorderTabs() {
                const tabsContainer = document.getElementById('tabs-container');
                const addButton = tabsContainer.querySelector('.add-tab');
                const dimsButton = tabsContainer.querySelector('[onclick*="dimensions"]');

                // Get all MSG tab buttons
                const msgButtons = Array.from(tabsContainer.querySelectorAll('.tab-button')).filter(
                    btn => btn.textContent.startsWith('MSG')
                );

                // Sort by MSG number
                msgButtons.sort((a, b) => {
                    const numA = parseInt(a.textContent.replace('MSG', ''));
                    const numB = parseInt(b.textContent.replace('MSG', ''));
                    return numA - numB;
                });

                // Remove all buttons
                msgButtons.forEach(btn => btn.remove());
                addButton.remove();
                dimsButton.remove();

                // Re-add in order
                msgButtons.forEach(btn => tabsContainer.appendChild(btn));
                tabsContainer.appendChild(addButton);
                tabsContainer.appendChild(dimsButton);
            }

            // Function to add a new tab
            function addNewTab() {
                const newMsgId = findNextMsgNumber();

                // Update message count if needed
                if (newMsgId > messageCount) {
                    messageCount = newMsgId;
                }

                // Initialize data for new message with default typography
                messageData[newMsgId] = {
                    text: 'MSG' + newMsgId,
                    // Typography defaults
                    fontFamily: 'Arial, sans-serif',
                    capHeight: 62.5,
                    lineHeight: 1.2,
                    letterSpacing: 0,
                    wordSpacing: 0,
                    // Position
                    boxX: 50,
                    boxY: 300 + (newMsgId - 1) * 50, // Offset each message slightly
                    boxWidth: 600,
                    boxHeight: 200,
                    // Alignment
                    horizontalAlign: 'center',
                    verticalAlign: 'middle',
                    // Braille
                    brailleEnabled: true,
                    brailleHeight: 23.9,
                    brailleGap: 40
                };

                // Create new tab button
                const tabsContainer = document.getElementById('tabs-container');
                const newTabButton = document.createElement('button');
                newTabButton.className = 'tab-button';
                newTabButton.textContent = 'MSG' + newMsgId;
                newTabButton.onclick = function () {
                    switchTab('msg-' + newMsgId, this);
                };

                // Add button to container
                const addButton = tabsContainer.querySelector('.add-tab');
                tabsContainer.insertBefore(newTabButton, addButton);

                // Create new tab content
                const newTabContent = createMessageTabContent(newMsgId);
                const dimensionsTab = document.getElementById('dimensions-tab');
                dimensionsTab.parentNode.insertBefore(newTabContent, dimensionsTab);

                // Reorder tabs to maintain sequence
                reorderTabs();

                // Switch to the new tab
                switchTab('msg-' + newMsgId, newTabButton);
            }

            // Function to create message tab content
            function createMessageTabContent(msgId) {
                const tabDiv = document.createElement('div');
                tabDiv.id = 'msg-' + msgId + '-tab';
                tabDiv.className = 'tab-content';
                tabDiv.setAttribute('data-msg-id', msgId);

                // Copy the structure from MSG1 tab
                const msg1Tab = document.getElementById('msg-1-tab');
                tabDiv.innerHTML = msg1Tab.innerHTML;

                // Add event listeners to the new tab's elements
                tabDiv.querySelector('#sign-text').addEventListener('input', updateText);
                tabDiv.querySelector('#font-family').addEventListener('change', updateText);
                tabDiv.querySelector('#cap-height').addEventListener('input', updateText);
                tabDiv.querySelector('#line-height').addEventListener('input', updateText);
                tabDiv.querySelector('#letter-spacing').addEventListener('input', updateText);
                tabDiv.querySelector('#word-spacing').addEventListener('input', updateText);
                tabDiv.querySelector('#box-x').addEventListener('input', updateText);
                tabDiv.querySelector('#box-y').addEventListener('input', updateText);
                tabDiv.querySelector('#box-width').addEventListener('input', updateText);
                tabDiv.querySelector('#box-height').addEventListener('input', updateText);
                tabDiv.querySelector('#text-h-align').addEventListener('change', updateText);
                tabDiv.querySelector('#text-v-align').addEventListener('change', updateText);
                tabDiv.querySelector('#enable-braille').addEventListener('change', updateText);
                tabDiv.querySelector('#braille-height').addEventListener('input', updateText);
                tabDiv.querySelector('#braille-gap').addEventListener('input', updateText);

                // Add delete button for MSG2+
                if (msgId > 1) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-tab-btn';
                    deleteBtn.textContent = 'Delete MSG' + msgId;
                    deleteBtn.onclick = () => deleteTab(msgId);
                    tabDiv.appendChild(deleteBtn);
                }

                return tabDiv;
            }

            // Function to delete a tab
            function deleteTab(msgId) {
                if (
                    confirm(
                        'Are you sure you want to delete MSG' + msgId + '? This cannot be undone.'
                    )
                ) {
                    // Remove tab button
                    const tabButtons = document.querySelectorAll('.tab-button');
                    tabButtons.forEach(button => {
                        if (button.textContent === 'MSG' + msgId) {
                            button.remove();
                        }
                    });

                    // Remove tab content
                    const tabContent = document.getElementById('msg-' + msgId + '-tab');
                    if (tabContent) {
                        tabContent.remove();
                    }

                    // Remove data
                    delete messageData[msgId];

                    // Switch to MSG1
                    switchTab('msg-1');
                }
            }

            // Add event listeners for text and spacing
            document.getElementById('sign-text').addEventListener('input', updateText);
            document.getElementById('font-family').addEventListener('change', updateText);
            document.getElementById('cap-height').addEventListener('input', updateText);
            document.getElementById('line-height').addEventListener('input', updateText);
            document.getElementById('letter-spacing').addEventListener('input', updateText);
            document.getElementById('word-spacing').addEventListener('input', updateText);
            document.getElementById('box-x').addEventListener('input', updateText);
            document.getElementById('box-y').addEventListener('input', updateText);
            document.getElementById('box-width').addEventListener('input', updateText);
            document.getElementById('box-height').addEventListener('input', updateText);
            document.getElementById('text-h-align').addEventListener('change', updateText);
            document.getElementById('text-v-align').addEventListener('change', updateText);

            // Add event listeners for sign dimensions
            document.getElementById('sign-width').addEventListener('input', updateSignDimensions);
            document.getElementById('sign-height').addEventListener('input', updateSignDimensions);
            document.getElementById('sign-dpi').addEventListener('input', updateSignDimensions);
            document.getElementById('show-rulers').addEventListener('change', () => {
                const showRulers = document.getElementById('show-rulers').checked;
                if (rulerGroup) {
                    rulerGroup.style('display', showRulers ? 'block' : 'none');
                }
            });

            // Add event listener for braille checkbox
            document.getElementById('enable-braille').addEventListener('change', updateText);

            // Add event listeners for braille height and gap inputs
            document.getElementById('braille-height').addEventListener('input', updateText);
            document.getElementById('braille-gap').addEventListener('input', updateText);

            // Add event listeners for color pickers
            document.getElementById('sign-color').addEventListener('input', () => {
                // Update background color and re-render
                const signColor = document.getElementById('sign-color').value;
                if (backgroundRect) {
                    backgroundRect.attr('fill', signColor);
                }
            });
            document.getElementById('text-color').addEventListener('input', updateText);
            document.getElementById('braille-color').addEventListener('input', updateText);

            // Save/Load Template Functions
            async function saveTemplate() {
                // Gather all template data
                const templateName = prompt('Enter template name:', 'Sign Template');
                if (!templateName) return; // User cancelled

                const templateData = {
                    name: templateName,
                    version: '1.0',
                    created: new Date().toISOString(),

                    // Sign dimensions
                    signWidth: parseInt(document.getElementById('sign-width').value),
                    signHeight: parseInt(document.getElementById('sign-height').value),
                    dpi: parseInt(document.getElementById('sign-dpi').value),

                    // Colors
                    colors: {
                        signBackground: document.getElementById('sign-color').value,
                        text: document.getElementById('text-color').value,
                        braille: document.getElementById('braille-color').value
                    },

                    // Typography settings
                    typography: {
                        fontFamily: document.getElementById('font-family').value,
                        capHeight: parseFloat(document.getElementById('cap-height').value),
                        lineHeight: parseFloat(document.getElementById('line-height').value),
                        letterSpacing: parseFloat(document.getElementById('letter-spacing').value),
                        wordSpacing: parseFloat(document.getElementById('word-spacing').value),
                        horizontalAlign: document.getElementById('text-h-align').value,
                        verticalAlign: document.getElementById('text-v-align').value
                    },

                    // Message areas
                    messages: {}
                };

                // Collect all message area data - including typography per message
                Object.keys(messageData).forEach(msgId => {
                    const msgData = messageData[msgId];
                    templateData.messages[msgId] = {
                        text: msgData.text,
                        // Typography settings per message
                        fontFamily: msgData.fontFamily || 'Arial, sans-serif',
                        capHeight: msgData.capHeight || 62.5,
                        lineHeight: msgData.lineHeight || 1.2,
                        letterSpacing: msgData.letterSpacing || 0,
                        wordSpacing: msgData.wordSpacing || 0,
                        // Position and size
                        boxX: msgData.boxX,
                        boxY: msgData.boxY,
                        boxWidth: msgData.boxWidth,
                        boxHeight: msgData.boxHeight,
                        // Alignment
                        horizontalAlign: msgData.horizontalAlign || 'center',
                        verticalAlign: msgData.verticalAlign || 'middle',
                        // Braille
                        brailleEnabled: msgData.brailleEnabled || false,
                        brailleHeight: msgData.brailleHeight || 23.9,
                        brailleGap: msgData.brailleGap || 40
                    };
                });

                // Logo data - include SVG content and position
                if (uploadedLogoSVG && logoPosition) {
                    templateData.logo = {
                        svgContent: uploadedLogoSVG, // Store the actual SVG content
                        x: logoPosition.x,
                        y: logoPosition.y,
                        width: logoPosition.width,
                        height: logoPosition.height
                    };
                }

                // Create JSON string
                const jsonStr = JSON.stringify(templateData, null, 2);

                // Try to use File System Access API for proper save dialog
                if ('showSaveFilePicker' in window) {
                    try {
                        // Show save file picker
                        const handle = await window.showSaveFilePicker({
                            suggestedName:
                                (templateName || 'template')
                                    .replace(/[^a-z0-9]/gi, '-')
                                    .toLowerCase() + '.json',
                            types: [
                                {
                                    description: 'JSON Template',
                                    accept: { 'application/json': ['.json'] }
                                }
                            ]
                        });

                        // Create a writable stream
                        const writable = await handle.createWritable();

                        // Write the JSON content
                        await writable.write(jsonStr);

                        // Close the file
                        await writable.close();

                        console.log('Template saved:', templateData);
                        alert('Template saved successfully!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Save error:', err);
                            // Fall back to download method
                            downloadTemplate(jsonStr, templateName);
                        }
                    }
                } else {
                    // Fallback for browsers without File System Access API
                    downloadTemplate(jsonStr, templateName);
                }
            }

            // Fallback download function
            function downloadTemplate(jsonStr, templateName) {
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download =
                    (templateName || 'template').replace(/[^a-z0-9]/gi, '-').toLowerCase() +
                    '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('Template downloaded (fallback method)');
            }

            function loadTemplate(file) {
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const templateData = JSON.parse(event.target.result);

                        // Apply dimensions
                        if (templateData.signWidth)
                            document.getElementById('sign-width').value = templateData.signWidth;
                        if (templateData.signHeight)
                            document.getElementById('sign-height').value = templateData.signHeight;
                        if (templateData.dpi)
                            document.getElementById('sign-dpi').value = templateData.dpi;

                        // Apply colors
                        if (templateData.colors) {
                            if (templateData.colors.signBackground)
                                document.getElementById('sign-color').value =
                                    templateData.colors.signBackground;
                            if (templateData.colors.text)
                                document.getElementById('text-color').value =
                                    templateData.colors.text;
                            if (templateData.colors.braille)
                                document.getElementById('braille-color').value =
                                    templateData.colors.braille;
                        }

                        // Apply typography
                        if (templateData.typography) {
                            const typo = templateData.typography;
                            if (typo.fontFamily)
                                document.getElementById('font-family').value = typo.fontFamily;
                            if (typo.capHeight)
                                document.getElementById('cap-height').value = typo.capHeight;
                            if (typo.lineHeight)
                                document.getElementById('line-height').value = typo.lineHeight;
                            if (typo.letterSpacing)
                                document.getElementById('letter-spacing').value =
                                    typo.letterSpacing;
                            if (typo.wordSpacing)
                                document.getElementById('word-spacing').value = typo.wordSpacing;
                            if (typo.horizontalAlign)
                                document.getElementById('text-h-align').value =
                                    typo.horizontalAlign;
                            if (typo.verticalAlign)
                                document.getElementById('text-v-align').value = typo.verticalAlign;
                        }

                        // Apply message areas
                        if (templateData.messages) {
                            // Clear existing messages (except MSG1)
                            messageData = { 1: messageData[1] }; // Keep MSG1

                            // Remove extra tabs
                            const tabsToRemove = document.querySelectorAll(
                                '.tab-button[data-msg-id]:not([onclick*="msg-1"])'
                            );
                            tabsToRemove.forEach(tab => tab.remove());
                            const contentToRemove = document.querySelectorAll(
                                '.tab-content[data-msg-id]:not([id="msg-1-tab"])'
                            );
                            contentToRemove.forEach(content => content.remove());

                            // Load messages from template
                            Object.keys(templateData.messages).forEach(msgId => {
                                const msgData = templateData.messages[msgId];

                                if (msgId === '1') {
                                    // Update MSG1 - including all position data
                                    messageData[1] = msgData;
                                    document.getElementById('sign-text').value = msgData.text || '';
                                    document.getElementById('box-x').value = msgData.boxX || 50;
                                    document.getElementById('box-y').value = msgData.boxY || 100;
                                    document.getElementById('box-width').value =
                                        msgData.boxWidth || 700;
                                    document.getElementById('box-height').value =
                                        msgData.boxHeight || 200;
                                    document.getElementById('enable-braille').checked =
                                        msgData.brailleEnabled || false;
                                    document.getElementById('braille-height').value =
                                        msgData.brailleHeight || 23.9;
                                    document.getElementById('braille-gap').value =
                                        msgData.brailleGap || 40;
                                } else {
                                    // Create new message tabs for additional messages
                                    addNewTab(false); // Don't switch to the new tab
                                    const newMsgId = Object.keys(messageData).length;
                                    messageData[newMsgId] = msgData;

                                    // Update the input fields for the new tab
                                    const newTab = document.querySelector(`#msg-${newMsgId}-tab`);
                                    if (newTab) {
                                        newTab.querySelector('#sign-text').value =
                                            msgData.text || '';
                                        newTab.querySelector('#box-x').value = msgData.boxX || 50;
                                        newTab.querySelector('#box-y').value = msgData.boxY || 100;
                                        newTab.querySelector('#box-width').value =
                                            msgData.boxWidth || 700;
                                        newTab.querySelector('#box-height').value =
                                            msgData.boxHeight || 200;
                                        newTab.querySelector('#enable-braille').checked =
                                            msgData.brailleEnabled || false;
                                        newTab.querySelector('#braille-height').value =
                                            msgData.brailleHeight || 23.9;
                                        newTab.querySelector('#braille-gap').value =
                                            msgData.brailleGap || 40;
                                    }
                                }
                            });
                        }

                        // Apply logo if exists
                        if (templateData.logo) {
                            // Restore logo position
                            logoPosition = {
                                x: templateData.logo.x,
                                y: templateData.logo.y,
                                width: templateData.logo.width,
                                height: templateData.logo.height
                            };

                            // Restore SVG content if present
                            if (templateData.logo.svgContent) {
                                uploadedLogoSVG = templateData.logo.svgContent;
                            }
                        }

                        // Re-render everything
                        updateSignDimensions();

                        alert(`Template "${templateData.name}" loaded successfully!`);
                    } catch (err) {
                        console.error('Error loading template:', err);
                        alert('Error loading template file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            }

            // Add save/load button event listeners
            document.getElementById('save-template-btn').addEventListener('click', saveTemplate);

            document.getElementById('load-template-btn').addEventListener('click', () => {
                document.getElementById('load-template-input').click();
            });

            document.getElementById('load-template-input').addEventListener('change', e => {
                const file = e.target.files[0];
                if (file && file.type === 'application/json') {
                    loadTemplate(file);
                }
                e.target.value = ''; // Reset for re-selection
            });

            // Initial render
            updateSignDimensions();
        </script>
    </body>
</html>
